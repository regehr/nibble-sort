#include <assert.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "nibble.h"

//#define TEST_SPECIAL_CASES

#define TEST_SIZE 1024

#if 0

/**** Nibble sorting algorithms ************************************************/

int regehr_read_nibble(unsigned long w, int i) {
  assert(i >= 0 && i < 16);
  unsigned long res = w >> (i * 4);
  return res & 0xf;
}

void regehr_write_nibble(unsigned long *w, int i, int v) {
  assert(i >= 0 && i < 16);
  unsigned long mask = 0xf;
  mask <<= (i * 4);
  *w &= ~mask;
  unsigned long prom = v;
  prom <<= (i * 4);
  *w |= prom;
}

unsigned long regehr_nibble_sort_word(unsigned long arg) {
  for (int i = 0; i < 16; ++i) {
    int min = i;
    for (int j = i+1; j < 16; ++j) {
      if (regehr_read_nibble(arg, j) < regehr_read_nibble(arg, min))
        min = j;
    }
    if (min != i) {
      int tmp = regehr_read_nibble(arg, i);
      regehr_write_nibble(&arg, i, regehr_read_nibble(arg, min));
      regehr_write_nibble(&arg, min, tmp);
    }
  }
  return arg;
}

void regehr_nibble_sort(unsigned long *buf)
{
  for (int i = 0; i < TEST_SIZE; i++)
  {
    buf[i] = regehr_nibble_sort_word(buf[i]);
  }
}

#endif

/******************************** my nibble sort starts here
 * *******************/

// pre-shifted values for each count of a given hex digit
static const unsigned long masks[16 * 17] __attribute__((aligned(64))) = {
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000,

    0x0000000000000000, 0x0000000000000001, 0x0000000000000011,
    0x0000000000000111, 0x0000000000001111, 0x0000000000011111,
    0x0000000000111111, 0x0000000001111111, 0x0000000011111111,
    0x0000000111111111, 0x0000001111111111, 0x0000011111111111,
    0x0000111111111111, 0x0001111111111111, 0x0011111111111111,
    0x0111111111111111, 0x1111111111111111,

    0x0000000000000000, 0x0000000000000002, 0x0000000000000022,
    0x0000000000000222, 0x0000000000002222, 0x0000000000022222,
    0x0000000000222222, 0x0000000002222222, 0x0000000022222222,
    0x0000000222222222, 0x0000002222222222, 0x0000022222222222,
    0x0000222222222222, 0x0002222222222222, 0x0022222222222222,
    0x0222222222222222, 0x2222222222222222,

    0x0000000000000000, 0x0000000000000003, 0x0000000000000033,
    0x0000000000000333, 0x0000000000003333, 0x0000000000033333,
    0x0000000000333333, 0x0000000003333333, 0x0000000033333333,
    0x0000000333333333, 0x0000003333333333, 0x0000033333333333,
    0x0000333333333333, 0x0003333333333333, 0x0033333333333333,
    0x0333333333333333, 0x3333333333333333,

    0x0000000000000000, 0x0000000000000004, 0x0000000000000044,
    0x0000000000000444, 0x0000000000004444, 0x0000000000044444,
    0x0000000000444444, 0x0000000004444444, 0x0000000044444444,
    0x0000000444444444, 0x0000004444444444, 0x0000044444444444,
    0x0000444444444444, 0x0004444444444444, 0x0044444444444444,
    0x0444444444444444, 0x4444444444444444,

    0x0000000000000000, 0x0000000000000005, 0x0000000000000055,
    0x0000000000000555, 0x0000000000005555, 0x0000000000055555,
    0x0000000000555555, 0x0000000005555555, 0x0000000055555555,
    0x0000000555555555, 0x0000005555555555, 0x0000055555555555,
    0x0000555555555555, 0x0005555555555555, 0x0055555555555555,
    0x0555555555555555, 0x5555555555555555,

    0x0000000000000000, 0x0000000000000006, 0x0000000000000066,
    0x0000000000000666, 0x0000000000006666, 0x0000000000066666,
    0x0000000000666666, 0x0000000006666666, 0x0000000066666666,
    0x0000000666666666, 0x0000006666666666, 0x0000066666666666,
    0x0000666666666666, 0x0006666666666666, 0x0066666666666666,
    0x0666666666666666, 0x6666666666666666,

    0x0000000000000000, 0x0000000000000007, 0x0000000000000077,
    0x0000000000000777, 0x0000000000007777, 0x0000000000077777,
    0x0000000000777777, 0x0000000007777777, 0x0000000077777777,
    0x0000000777777777, 0x0000007777777777, 0x0000077777777777,
    0x0000777777777777, 0x0007777777777777, 0x0077777777777777,
    0x0777777777777777, 0x7777777777777777,

    0x0000000000000000, 0x0000000000000008, 0x0000000000000088,
    0x0000000000000888, 0x0000000000008888, 0x0000000000088888,
    0x0000000000888888, 0x0000000008888888, 0x0000000088888888,
    0x0000000888888888, 0x0000008888888888, 0x0000088888888888,
    0x0000888888888888, 0x0008888888888888, 0x0088888888888888,
    0x0888888888888888, 0x8888888888888888,

    0x0000000000000000, 0x0000000000000009, 0x0000000000000099,
    0x0000000000000999, 0x0000000000009999, 0x0000000000099999,
    0x0000000000999999, 0x0000000009999999, 0x0000000099999999,
    0x0000000999999999, 0x0000009999999999, 0x0000099999999999,
    0x0000999999999999, 0x0009999999999999, 0x0099999999999999,
    0x0999999999999999, 0x9999999999999999,

    0x0000000000000000, 0x000000000000000A, 0x00000000000000AA,
    0x0000000000000AAA, 0x000000000000AAAA, 0x00000000000AAAAA,
    0x0000000000AAAAAA, 0x000000000AAAAAAA, 0x00000000AAAAAAAA,
    0x0000000AAAAAAAAA, 0x000000AAAAAAAAAA, 0x00000AAAAAAAAAAA,
    0x0000AAAAAAAAAAAA, 0x000AAAAAAAAAAAAA, 0x00AAAAAAAAAAAAAA,
    0x0AAAAAAAAAAAAAAA, 0xAAAAAAAAAAAAAAAA,

    0x0000000000000000, 0x000000000000000B, 0x00000000000000BB,
    0x0000000000000BBB, 0x000000000000BBBB, 0x00000000000BBBBB,
    0x0000000000BBBBBB, 0x000000000BBBBBBB, 0x00000000BBBBBBBB,
    0x0000000BBBBBBBBB, 0x000000BBBBBBBBBB, 0x00000BBBBBBBBBBB,
    0x0000BBBBBBBBBBBB, 0x000BBBBBBBBBBBBB, 0x00BBBBBBBBBBBBBB,
    0x0BBBBBBBBBBBBBBB, 0xBBBBBBBBBBBBBBBB,

    0x0000000000000000, 0x000000000000000C, 0x00000000000000CC,
    0x0000000000000CCC, 0x000000000000CCCC, 0x00000000000CCCCC,
    0x0000000000CCCCCC, 0x000000000CCCCCCC, 0x00000000CCCCCCCC,
    0x0000000CCCCCCCCC, 0x000000CCCCCCCCCC, 0x00000CCCCCCCCCCC,
    0x0000CCCCCCCCCCCC, 0x000CCCCCCCCCCCCC, 0x00CCCCCCCCCCCCCC,
    0x0CCCCCCCCCCCCCCC, 0xCCCCCCCCCCCCCCCC,

    0x0000000000000000, 0x000000000000000D, 0x00000000000000DD,
    0x0000000000000DDD, 0x000000000000DDDD, 0x00000000000DDDDD,
    0x0000000000DDDDDD, 0x000000000DDDDDDD, 0x00000000DDDDDDDD,
    0x0000000DDDDDDDDD, 0x000000DDDDDDDDDD, 0x00000DDDDDDDDDDD,
    0x0000DDDDDDDDDDDD, 0x000DDDDDDDDDDDDD, 0x00DDDDDDDDDDDDDD,
    0x0DDDDDDDDDDDDDDD, 0xDDDDDDDDDDDDDDDD,

    0x0000000000000000, 0x000000000000000E, 0x00000000000000EE,
    0x0000000000000EEE, 0x000000000000EEEE, 0x00000000000EEEEE,
    0x0000000000EEEEEE, 0x000000000EEEEEEE, 0x00000000EEEEEEEE,
    0x0000000EEEEEEEEE, 0x000000EEEEEEEEEE, 0x00000EEEEEEEEEEE,
    0x0000EEEEEEEEEEEE, 0x000EEEEEEEEEEEEE, 0x00EEEEEEEEEEEEEE,
    0x0EEEEEEEEEEEEEEE, 0xEEEEEEEEEEEEEEEE,

    0x0000000000000000, 0x000000000000000F, 0x00000000000000FF,
    0x0000000000000FFF, 0x000000000000FFFF, 0x00000000000FFFFF,
    0x0000000000FFFFFF, 0x000000000FFFFFFF, 0x00000000FFFFFFFF,
    0x0000000FFFFFFFFF, 0x000000FFFFFFFFFF, 0x00000FFFFFFFFFFF,
    0x0000FFFFFFFFFFFF, 0x000FFFFFFFFFFFFF, 0x00FFFFFFFFFFFFFF,
    0x0FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};

// each nibble in the following table contains the count of the corresponding
// hex digit for any given byte
static const long increments[256] __attribute__((aligned(64))) = {
    0x0000000000000002, 0x0000000000000011, 0x0000000000000101,
    0x0000000000001001, 0x0000000000010001, 0x0000000000100001,
    0x0000000001000001, 0x0000000010000001, 0x0000000100000001,
    0x0000001000000001, 0x0000010000000001, 0x0000100000000001,
    0x0001000000000001, 0x0010000000000001, 0x0100000000000001,
    0x1000000000000001, 0x0000000000000011, 0x0000000000000020,
    0x0000000000000110, 0x0000000000001010, 0x0000000000010010,
    0x0000000000100010, 0x0000000001000010, 0x0000000010000010,
    0x0000000100000010, 0x0000001000000010, 0x0000010000000010,
    0x0000100000000010, 0x0001000000000010, 0x0010000000000010,
    0x0100000000000010, 0x1000000000000010, 0x0000000000000101,
    0x0000000000000110, 0x0000000000000200, 0x0000000000001100,
    0x0000000000010100, 0x0000000000100100, 0x0000000001000100,
    0x0000000010000100, 0x0000000100000100, 0x0000001000000100,
    0x0000010000000100, 0x0000100000000100, 0x0001000000000100,
    0x0010000000000100, 0x0100000000000100, 0x1000000000000100,
    0x0000000000001001, 0x0000000000001010, 0x0000000000001100,
    0x0000000000002000, 0x0000000000011000, 0x0000000000101000,
    0x0000000001001000, 0x0000000010001000, 0x0000000100001000,
    0x0000001000001000, 0x0000010000001000, 0x0000100000001000,
    0x0001000000001000, 0x0010000000001000, 0x0100000000001000,
    0x1000000000001000, 0x0000000000010001, 0x0000000000010010,
    0x0000000000010100, 0x0000000000011000, 0x0000000000020000,
    0x0000000000110000, 0x0000000001010000, 0x0000000010010000,
    0x0000000100010000, 0x0000001000010000, 0x0000010000010000,
    0x0000100000010000, 0x0001000000010000, 0x0010000000010000,
    0x0100000000010000, 0x1000000000010000, 0x0000000000100001,
    0x0000000000100010, 0x0000000000100100, 0x0000000000101000,
    0x0000000000110000, 0x0000000000200000, 0x0000000001100000,
    0x0000000010100000, 0x0000000100100000, 0x0000001000100000,
    0x0000010000100000, 0x0000100000100000, 0x0001000000100000,
    0x0010000000100000, 0x0100000000100000, 0x1000000000100000,
    0x0000000001000001, 0x0000000001000010, 0x0000000001000100,
    0x0000000001001000, 0x0000000001010000, 0x0000000001100000,
    0x0000000002000000, 0x0000000011000000, 0x0000000101000000,
    0x0000001001000000, 0x0000010001000000, 0x0000100001000000,
    0x0001000001000000, 0x0010000001000000, 0x0100000001000000,
    0x1000000001000000, 0x0000000010000001, 0x0000000010000010,
    0x0000000010000100, 0x0000000010001000, 0x0000000010010000,
    0x0000000010100000, 0x0000000011000000, 0x0000000020000000,
    0x0000000110000000, 0x0000001010000000, 0x0000010010000000,
    0x0000100010000000, 0x0001000010000000, 0x0010000010000000,
    0x0100000010000000, 0x1000000010000000, 0x0000000100000001,
    0x0000000100000010, 0x0000000100000100, 0x0000000100001000,
    0x0000000100010000, 0x0000000100100000, 0x0000000101000000,
    0x0000000110000000, 0x0000000200000000, 0x0000001100000000,
    0x0000010100000000, 0x0000100100000000, 0x0001000100000000,
    0x0010000100000000, 0x0100000100000000, 0x1000000100000000,
    0x0000001000000001, 0x0000001000000010, 0x0000001000000100,
    0x0000001000001000, 0x0000001000010000, 0x0000001000100000,
    0x0000001001000000, 0x0000001010000000, 0x0000001100000000,
    0x0000002000000000, 0x0000011000000000, 0x0000101000000000,
    0x0001001000000000, 0x0010001000000000, 0x0100001000000000,
    0x1000001000000000, 0x0000010000000001, 0x0000010000000010,
    0x0000010000000100, 0x0000010000001000, 0x0000010000010000,
    0x0000010000100000, 0x0000010001000000, 0x0000010010000000,
    0x0000010100000000, 0x0000011000000000, 0x0000020000000000,
    0x0000110000000000, 0x0001010000000000, 0x0010010000000000,
    0x0100010000000000, 0x1000010000000000, 0x0000100000000001,
    0x0000100000000010, 0x0000100000000100, 0x0000100000001000,
    0x0000100000010000, 0x0000100000100000, 0x0000100001000000,
    0x0000100010000000, 0x0000100100000000, 0x0000101000000000,
    0x0000110000000000, 0x0000200000000000, 0x0001100000000000,
    0x0010100000000000, 0x0100100000000000, 0x1000100000000000,
    0x0001000000000001, 0x0001000000000010, 0x0001000000000100,
    0x0001000000001000, 0x0001000000010000, 0x0001000000100000,
    0x0001000001000000, 0x0001000010000000, 0x0001000100000000,
    0x0001001000000000, 0x0001010000000000, 0x0001100000000000,
    0x0002000000000000, 0x0011000000000000, 0x0101000000000000,
    0x1001000000000000, 0x0010000000000001, 0x0010000000000010,
    0x0010000000000100, 0x0010000000001000, 0x0010000000010000,
    0x0010000000100000, 0x0010000001000000, 0x0010000010000000,
    0x0010000100000000, 0x0010001000000000, 0x0010010000000000,
    0x0010100000000000, 0x0011000000000000, 0x0020000000000000,
    0x0110000000000000, 0x1010000000000000, 0x0100000000000001,
    0x0100000000000010, 0x0100000000000100, 0x0100000000001000,
    0x0100000000010000, 0x0100000000100000, 0x0100000001000000,
    0x0100000010000000, 0x0100000100000000, 0x0100001000000000,
    0x0100010000000000, 0x0100100000000000, 0x0101000000000000,
    0x0110000000000000, 0x0200000000000000, 0x1100000000000000,
    0x1000000000000001, 0x1000000000000010, 0x1000000000000100,
    0x1000000000001000, 0x1000000000010000, 0x1000000000100000,
    0x1000000001000000, 0x1000000010000000, 0x1000000100000000,
    0x1000001000000000, 0x1000010000000000, 0x1000100000000000,
    0x1001000000000000, 0x1010000000000000, 0x1100000000000000,
    0x2000000000000000};

inline static unsigned long sort_nibbles(unsigned long value) {
  // check for the special case where all 16 digits are the same
  if ((value << 4 | value >> 60) == value) {
    // just return the given value as in this case the counter nibble will
    // overflow giving the incorrect result
    return value;
  }

  unsigned long counter;
  unsigned long result;

  // use the increments table to look at each byte in the value and update the
  // counter appropriately
  counter = increments[value & 0xff];
  counter += increments[(value >> 8) & 0xff];
  counter += increments[(value >> 16) & 0xff];
  counter += increments[(value >> 24) & 0xff];
  counter += increments[(value >> 32) & 0xff];
  counter += increments[(value >> 40) & 0xff];
  counter += increments[(value >> 48) & 0xff];
  counter += increments[(value >> 56) & 0xff];

  // now look at each nibble of the counter in turn and use the mask table to
  // build up the result
  result = masks[15 * 17 + (counter >> 60)];
  result = result << ((counter >> 54) & 0x3c) |
           masks[14 * 17 + ((counter >> 56) & 0xf)];
  result = result << ((counter >> 50) & 0x3c) |
           masks[13 * 17 + ((counter >> 52) & 0xf)];
  result = result << ((counter >> 46) & 0x3c) |
           masks[12 * 17 + ((counter >> 48) & 0xf)];
  result = result << ((counter >> 42) & 0x3c) |
           masks[11 * 17 + ((counter >> 44) & 0xf)];
  result = result << ((counter >> 38) & 0x3c) |
           masks[10 * 17 + ((counter >> 40) & 0xf)];
  result = result << ((counter >> 34) & 0x3c) |
           masks[9 * 17 + ((counter >> 36) & 0xf)];
  result = result << ((counter >> 30) & 0x3c) |
           masks[8 * 17 + ((counter >> 32) & 0xf)];
  result = result << ((counter >> 26) & 0x3c) |
           masks[7 * 17 + ((counter >> 28) & 0xf)];
  result = result << ((counter >> 22) & 0x3c) |
           masks[6 * 17 + ((counter >> 24) & 0xf)];
  result = result << ((counter >> 18) & 0x3c) |
           masks[5 * 17 + ((counter >> 20) & 0xf)];
  result = result << ((counter >> 14) & 0x3c) |
           masks[4 * 17 + ((counter >> 16) & 0xf)];
  result = result << ((counter >> 10) & 0x3c) |
           masks[3 * 17 + ((counter >> 12) & 0xf)];
  result = result << ((counter >> 6) & 0x3c) |
           masks[2 * 17 + ((counter >> 8) & 0xf)];
  result =
      result << ((counter >> 2) & 0x3c) | masks[17 + ((counter >> 4) & 0xf)];
  result = result << ((counter << 2) & 0x3c);

  return result;
}

void nibble_sort_parnell(unsigned long *buf) {
  for (int i = 0; i < TEST_SIZE; i++) {
    buf[i] = sort_nibbles(buf[i]);
  }
}

#if 0

/**** Benchmarking framework ***************************************************/

unsigned long input[TEST_SIZE];
unsigned long expected_output[TEST_SIZE];
unsigned long actual_output[TEST_SIZE];

unsigned char random_byte()
{
  return rand();
}

typedef void buffer_sorter(unsigned long *buf);

unsigned long sort_buffer_timed(unsigned long *input, unsigned long *output,
    buffer_sorter * sorter)
{
  memcpy(output, input, TEST_SIZE * sizeof(unsigned long));
  clock_t start = clock();
  sorter(output);
  clock_t end = clock();
  unsigned long diff = end - start;
  assert(CLOCKS_PER_SEC == 1000000);
  printf("Time (\u00B5s): %lu\n", diff);

  return diff;
}

void generate_input_data()
{
#ifdef TEST_SPECIAL_CASES
  input[0] = 0x0123456789ABCDEF;
  input[1] = 0xffffffffffffffff;
  input[2] = 0x1111111111111111;
  input[3] = 0x3434343434343434;
#else
  srand(44);
  for (int i = 0; i < TEST_SIZE; i++)
  {
    input[i] =
      ((unsigned long)random_byte() << 0) |
      ((unsigned long)random_byte() << 8) |
      ((unsigned long)random_byte() << 16) |
      ((unsigned long)random_byte() << 24) |
      ((unsigned long)random_byte() << 32) |
      ((unsigned long)random_byte() << 40) |
      ((unsigned long)random_byte() << 48) |
      ((unsigned long)random_byte() << 56);
  }
#endif
}

int error_count;

void check_output(unsigned long *input, unsigned long *expected, unsigned long *actual)
{
  error_count = 0;
  for (int i = 0; i < TEST_SIZE; i++)
  {
    if (expected[i] != actual[i])
    {
      fprintf(stderr, "Error (i=%d, input=%lx): expected %lx, got %lx\n",
          i, input[i], expected[i], actual[i]);
      error_count++;
      if (error_count >= 100)
      {
        fprintf(stderr, "Too many errors, aborting.\n");
        return;
      }
    }
  }
}

int main()
{
  generate_input_data();
  unsigned long original_time = sort_buffer_timed(input, expected_output, regehr_nibble_sort);
  unsigned long tweaked_time = sort_buffer_timed(input, actual_output, my_nibble_sort);
  check_output(input, expected_output, actual_output);
  if(error_count == 0) {
    printf("Ratio: %0.2f\n", (double)original_time/(double)tweaked_time);
  }
  return error_count ? 1 : 0;
}

#endif
